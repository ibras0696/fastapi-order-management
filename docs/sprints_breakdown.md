# Спринты и чек-листы (по ТЗ)

## Ключевые требования ТЗ (кратко)

- FastAPI + Swagger UI
- Auth (JWT, OAuth2 Password Flow):
  - `POST /register/` — регистрация (email, пароль)
  - `POST /token/` — получение JWT
- Orders:
  - `POST /orders/` — создать заказ (только авторизованные)
  - `GET /orders/{order_id}/` — получить заказ (сначала Redis; TTL 5 минут)
  - `PATCH /orders/{order_id}/` — обновить статус
  - `GET /orders/user/{user_id}/` — получить заказы пользователя
- PostgreSQL (SQLAlchemy) + Alembic: таблица `orders` (UUID, user_id, items JSON, total_price, status enum, created_at)
- Redis: кеширование заказов (TTL=5 минут), обновление кеша при изменениях, fallback на БД при ошибках Redis
- Kafka/RabbitMQ: используется как event-bus между сервисами (не “брокер Celery”)
  - при создании заказа публикуется событие `new_order`
  - отдельный consumer читает `new_order` и запускает фоновые задачи в Celery/Taskiq
- Celery/Taskiq: только выполнение фоновых задач
- Безопасность: CORS, rate limiting, только ORM-запросы

## Production-ready требования (из HR/ожиданий ревью)

- Graceful degradation:
  - Redis недоступен → API не падает, читаем из БД
  - Kafka/RabbitMQ недоступны → заказ не “ломает” API бездумным 500; нужна стратегия (минимум логирование + retry; лучше outbox)
- DRY: сериализация/маппинг `Order` в ответ — в одном месте
- Валидация `items`: не принимать пустые/битые товары без обязательных полей
- Никаких `print()` в критичных местах — только логирование

---

# План спринтов

## Sprint 0 — Каркас, конфиг, инфраструктура

Цель: подготовить репозиторий и окружение так, чтобы дальше фичи делались быстро и одинаково в dev/CI.

Чек-лист (должно работать после спринта):
- [ ] Приложение поднимается локально (FastAPI стартует, Swagger доступен)
- [ ] Конфигурация через env (есть `.env.example`, секреты не захардкожены)
- [ ] Настроено логирование (единый логгер, уровни, без `print()`)
- [ ] Есть удобный `Makefile` (минимум: `make run`, `make test`, `make lint`/`format`, `make migrate`)
- [ ] Docker Compose поднимает инфраструктуру (PostgreSQL, Redis, Kafka/RabbitMQ — по выбранному варианту)
- [ ] Базовая структура модулей (app/config, app/logging, app/api, app/db, app/services)

## Sprint 1 — БД + аутентификация

Цель: заложить фундамент (пользователь + JWT), чтобы защищать эндпоинты заказов.

Чек-лист:
- [ ] Alembic миграции создаются и применяются (чистая БД → рабочее состояние)
- [ ] `POST /register/` регистрирует пользователя (валидирует входные данные)
- [ ] `POST /token/` выдаёт JWT по OAuth2 Password Flow
- [ ] Защита эндпоинтов работает (без токена — 401/403, с токеном — доступ)
- [ ] Есть `pytest` тесты на регистрацию/логин/ошибки

## Sprint 2 — Заказы: CRUD + валидация + DRY ответы

Цель: реализовать основной бизнес-функционал без кеша и без очередей, но “правильно”.

Чек-лист:
- [ ] `POST /orders/` создаёт заказ (только авторизованные)
- [ ] `items` валидируется (структура товаров, обязательные поля, непустой список)
- [ ] `GET /orders/{order_id}/` возвращает заказ из БД
- [ ] `PATCH /orders/{order_id}/` обновляет статус (валидный enum; корректные 404/422)
- [ ] `GET /orders/user/{user_id}/` возвращает список заказов пользователя
- [ ] Сериализация/маппинг заказа в JSON не дублируется (единая функция/схема)
- [ ] Есть `pytest` тесты на happy-path и ошибки (401/403/404/422)

## Sprint 3 — Redis кеш (TTL=5 минут) + graceful degradation

Цель: ускорить чтение заказов и сделать API устойчивым к падению Redis.

Чек-лист:
- [ ] `GET /orders/{order_id}/` сначала пытается Redis, при промахе — читает из БД и кладёт в кеш
- [ ] TTL для кеша заказа = 5 минут
- [ ] При изменении заказа (`PATCH`) кеш обновляется/инвалидируется
- [ ] Если Redis недоступен/ошибка сети — эндпоинты не падают, есть fallback на БД + логирование
- [ ] Есть тесты/проверки сценариев кеш-хит/кеш-мисс/Redis-down

## Sprint 4 — Event-bus (Kafka/RabbitMQ) + consumer + надёжная публикация

Цель: реализовать событийную обработку заказа без потери событий.

Чек-лист:
- [ ] При создании заказа публикуется событие `new_order` (event-bus)
- [ ] Отдельный consumer читает `new_order` и инициирует фоновую задачу (Celery/Taskiq)
- [ ] При недоступности Kafka/RabbitMQ сервис ведёт себя предсказуемо:
  - [ ] событие не теряется (минимум retry/логирование; лучше outbox/отложенная доставка)
  - [ ] API не “роняет” всё приложение из-за брокера
- [ ] Есть проверка/тест, что событие доходит до consumer (интеграционно через docker-compose или e2e)

## Sprint 5 — Фоновые задачи + CORS + rate limiting + финальная приёмка

Цель: закрыть безопасность/фоновые задачи и привести проект к критериям приёмки.

Чек-лист:
- [ ] Фоновая задача реально выполняется (пример: `sleep(2)` + лог “order processed”)
- [ ] Consumer запускает фоновые задачи стабильно (без `print()`, с логами)
- [ ] CORS настроен (ограничения доменов/методов/заголовков)
- [ ] Rate limiting работает (и проверяемо через `curl`/тесты)
- [ ] README описывает запуск/проверку (docker-compose, миграции, тесты, curl примеры)
- [ ] Все критерии приёмки из ТЗ выполняются (API, auth, Redis, broker, фоновые, docker-compose, Swagger)
